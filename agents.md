## Agents and AI in this codebase

This document explains how AI “agents” are wired into the app, how we generate and persist Personas using the Vercel AI SDK v5, and how this integrates with Convex. It also codifies Convex best practices relevant to our flows.

### Architecture at a glance
- **UI**: Next.js App Router, server components preferred; client components only when needed.
- **AI**: Vercel AI SDK v5 (`ai`, `@ai-sdk/openai`) with structured outputs via `generateObject`.
- **Domain**: Standardized personas with strong typing and Zod validation.
- **Backend**: Convex actions/mutations/queries for AI calls and persistence.

Key files:
- `lib/personas/personaGroups.ts`: group catalog + derived helpers.
- `lib/personas/types.ts`: TS interfaces for Persona and related shapes.
- `lib/personas/schemas.ts`: Zod schemas mirroring the interfaces (strict JSON validation).
- `lib/personas/prompt.ts`: prompt builder for persona generation.
- `convex/personas.ts`: Convex action `generate` (AI call) and mutation `saveMany` (persistence).
- `convex/schema.ts`: Convex tables; includes `personas` table.

### Persona generation agent
- Uses `generateObject` (non‑streaming) with `openai('gpt-5')` and `strictJsonSchema` to return validated `Persona[]`.
- `Persona` fields include OCEAN personality scores, profile, and pre‑ad context. The `emotional_state` inside `pre_ad_context` is now derived by the model (not an input).
- Inputs: `{ group, count, context?: { scenario?, current_activity? } }`.

Why structured outputs: Zod schemas are enforced at generation time, preventing malformed data and reducing ad‑hoc validation.

### Data persistence (Convex)
- Table: `personas` mirrors the `Persona` structure. Results generated by the action are persisted via `saveMany`.
- Recommended indexes (future):
  - `by_group` on `personaGroup` for fast filtering.
  - `by_persona_id` on `persona_id` for quick lookups.

### Usage examples
Server component calling Convex action (preferred):
```ts
import { api } from '@/convex/_generated/api';
import { fetchAction } from 'convex/nextjs';

const personas = await fetchAction(api.personas.generate, {
  group: 'fitness',
  count: 2,
  context: { scenario: 'Instagram browsing', current_activity: 'Commute' },
});
```

Server action (alternative) returning `Persona[]` without persistence:
```ts
import { generatePersonas } from '@/lib/personas/generate';

const personas = await generatePersonas({
  group: 'tech',
  count: 3,
  context: { scenario: 'YouTube reviews', current_activity: 'Evening wind‑down' },
});
```

### Error handling and safety
- `generateObject` may throw `NoObjectGeneratedError`. We log provider details (cause, text, response, usage) and rethrow.
- Use `strictJsonSchema` to reduce schema drift.
- Cap `count` (e.g., 1–10) to control cost/latency.
- Avoid logging sensitive content; keep `chain_of_thought` concise.

### Environment & configuration
- Set `OPENAI_API_KEY` in Convex: `npx convex env set OPENAI_API_KEY <key>`.
- Ensure `ai`, `@ai-sdk/openai`, and `zod` are installed.

### Convex development guide (best practices)
- TypeScript: concise, functional style; descriptive variable names; prefer `interface` over type aliases for objects.
- Components: export named components; decompose into subcomponents/helpers; keep client components minimal.
- Errors: fail early; log actionable details; surface user‑friendly messages; validate inputs with Zod on boundaries.
- UI: shadcn/ui, Radix primitives, Tailwind; responsive, mobile‑first.
- Performance: minimize `use client`, state, and effects; prefer RSC; use `Suspense`; dynamic import heavy UI; optimize images.
- URLs/State: prefer `nuqs` (URL state) when applicable; watch Core Web Vitals; keep `useClient` limited.
- Convex data: prefer indexed queries over `.filter()` chains. Define indexes in `schema.ts` and query with `.withIndex(...)`.
- Actions vs mutations vs queries:
  - Use **actions** for external network I/O (e.g., calling AI providers), then commit via **mutations**.
  - Use **queries** for reads; paginate or cap results.
- HTTP Router & scheduled jobs: keep handlers small, validate inputs, and reuse domain helpers.
- File handling: upload via generated URL, then persist storage IDs in mutations.

Index example (messages table):
```ts
// schema.ts
defineTable({
  channel: v.id('channels'),
  body: v.string(),
  user: v.id('users'),
})
  .index('by_channel', ['channel'])
  .index('by_channel_user', ['channel', 'user']);

// query
await ctx.db
  .query('messages')
  .withIndex('by_channel', q => q.eq('channel', channel))
  .collect();
```

### Extensibility roadmap
- Add ad and reaction generators using the same `generateObject` pattern with dedicated Zod schemas.
- Add Convex queries to fetch personas by `personaGroup` and `persona_id` using indexes.
- Optional: a streaming variant (`streamObject`) for interactive UIs.
- Add rate limiting/quotas per user for generation endpoints.

### Quick checklist
- [ ] Inputs validated with Zod
- [ ] `strictJsonSchema` enabled for AI calls
- [ ] Results persisted via Convex mutation
- [ ] Indexes defined for query patterns
- [ ] Sensitive fields not logged; concise reasoning
- [ ] Client components minimized; RSC where possible


