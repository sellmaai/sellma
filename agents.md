## Agents and AI in this codebase

This document explains how AI “agents” are wired into the app, how we generate and persist Personas using the Vercel AI SDK v5, and how this integrates with Convex. It also codifies Convex best practices relevant to our flows.

### Architecture at a glance
- **UI**: Next.js App Router, server components preferred; client components only when needed.
- **AI**: Vercel AI SDK v5 (`ai`, `@ai-sdk/google`) with Gemini and structured outputs via `generateObject`. Uses `gemini-2.5-flash` for personas, ads, and simulation; `gemini-2.5-pro` for audience segmentation.
- **Domain**: Standardized personas with strong typing and Zod validation.
- **Backend**: Convex actions/mutations/queries for AI calls and persistence.

Key files:
- `lib/personas/types.ts`: TS interfaces for Persona and related shapes.
- `lib/personas/schemas.ts`: Zod schemas mirroring the interfaces (strict JSON validation).
- `lib/personas/prompt.ts`: prompt builders for persona generation (single and batch).
- `lib/personas/generate.ts`: server action for generating personas without persistence.
- `lib/personas/grouping/schemas.ts`: Zod schemas for audience segmentation.
- `lib/personas/grouping/prompt.ts`: prompt builders for audience overview and subsegments.
- `lib/ads/schemas.ts`: Zod schemas for ad variants.
- `lib/ads/prompt.ts`: prompt builder for ad variant generation.
- `lib/simulation/schemas.ts`: Zod schemas for persona reactions to ads.
- `lib/simulation/prompt.ts`: prompt builder for ad simulation.
- `convex/personas.ts`: Convex action `generate` (AI call), action `generateForGroups` (batch orchestrator), queries (`listByGroup`, `getByPersonaId`, `listByAudienceId`), and mutation `saveMany` (persistence).
- `convex/audienceGroups.ts`: Convex action `suggestBundle` (audience → overview + subsegments).
- `convex/ads.ts`: Convex action `generateVariants` (ad variants).
- `convex/simulation.ts`: Convex action `simulate` (persona reactions to ads).
- `convex/schema.ts`: Convex tables; includes `personas` table with indexes.

### Persona generation agent
- Uses `generateObject` (non‑streaming) with `google('gemini-2.5-flash')` to return validated `Persona[]`.
- `Persona` fields include OCEAN personality scores, profile, and pre‑ad context. The `scenario`, `current_activity`, and `emotional_state` inside `pre_ad_context` are derived by the model (not inputs).
- Inputs: `{ group, count, audienceId?, context?: { location?, audienceDescription?, segment? } }`.
- The `group` parameter is dynamic (not limited to a static catalog). It typically comes from the `id` field of a subsegment generated by `suggestBundle` (e.g., `urban-cyclists`, `weekend-riders`).
- The prompt prioritizes: audienceDescription (primary) → segment (secondary) → group ID (tertiary) → location.
- The model sets the `audienceGroup` field in each persona to match the provided `group` ID exactly.

Why structured outputs: Zod schemas are enforced at generation time, preventing malformed data and reducing ad‑hoc validation.

### Audience segmentation agent
- Uses `generateObject` with `google('gemini-2.5-pro')` to return validated audience overview and subsegments.
- Inputs: `{ text, location?, count? }` where `text` is the audience description.
- Returns: `{ description: string, groups: Array<{ id, label, description, color, percent }> }`.
- The `percent` fields sum to 100, representing the distribution across subsegments.
- Each subsegment has a unique kebab-case `id` that can be used as `audienceGroup` when generating personas.
- Falls back to a two-step approach (overview + subsegments separately) if the bundled generation fails.

### Batch persona generation
- The `generateForGroups` action orchestrates persona generation across multiple audience groups in a single AI call.
- Inputs: `{ groups: Array<{ id, label, description, color, percent? }>, total?, audienceId?, context? }`.
- Distributes the total count evenly across groups (with remainder handling).
- Uses `buildBatchPersonaPrompt` to instruct the model on the exact distribution by `audienceGroup`.
- Returns and persists all personas with their respective `audienceGroup` and `audienceId` tags.
- Significantly more efficient than calling `generate` sequentially for each group.

### Ad variants agent
- Uses `generateObject` with `google('gemini-2.5-flash')` to generate ad variants.
- Inputs: `{ count, source: { headline, description, angle? }, audienceHint? }`.
- Returns: `AdVariant[]` with fields `{ headline, description, angle? }`.
- Varies tone, structure, and focus while staying faithful to the source ad's product value.
- Constraints: headline ≤ 120 chars, description ≤ 300 chars.

### Simulation agent
- Uses `generateObject` with `google('gemini-2.5-flash')` to simulate persona reactions to ads.
- Inputs: `{ persona, ads: Array<{ id?, headline, description, angle? }> }`.
- Returns: `AdReactions` with `persona_id` and `reactions_to_variants[]`.
- Each reaction includes: `emotional_response` (1–5 terms), `cognitive_response`, `predicted_behavior` (enum), `engagement_score` (0–1), and `justification`.
- Behavior enum: `CLICK`, `SAVE_FOR_LATER`, `RESEARCH_FURTHER`, `IGNORE`, `SHARE`.

### Data persistence (Convex)
- Table: `personas` mirrors the `Persona` structure. Results generated by the action are persisted via `saveMany`.
- Indexes:
  - `by_group` on `audienceGroup` for fast filtering.
  - `by_persona_id` on `persona_id` for quick lookups.
  - `by_audience` on `audienceId` for session‑scoped lists.
- Saved personas include a stable `audienceGroup` (canonical ID) and `audienceId` tag for the current generation session.
- Note: Ad variants and simulation results are currently not persisted in the database (generated on-demand).

### Querying personas
Available Convex queries:
- `listByGroup({ group, limit? })`: Returns personas filtered by `audienceGroup`, ordered by creation time (desc), limited to 100 by default.
- `getByPersonaId({ persona_id })`: Returns a single persona by its unique `persona_id`, or `null` if not found.
- `listByAudienceId({ audienceId, limit? })`: Returns personas filtered by `audienceId` (session tag), ordered by creation time (desc), limited to 100 by default.

Example:
```ts
import { useQuery } from 'convex/react';
import { api } from '@/convex/_generated/api';

const personas = useQuery(api.personas.listByAudienceId, { audienceId: 'aud-123', limit: 50 });
```

### Usage examples
Server component calling Convex action (preferred):
```ts
import { api } from '@/convex/_generated/api';
import { fetchAction } from 'convex/nextjs';

const personas = await fetchAction(api.personas.generate, {
  group: 'fitness',
  count: 2,
  audienceId: 'aud-123',
  context: {
    location: 'Austin, TX',
    audienceDescription: 'Young professionals seeking eco‑friendly commuting options',
    segment: {
      id: 'urban-cyclists',
      label: 'Urban Cyclists',
      description: 'Commute by bike 3–5x/week; value durability, safety, and style.'
    }
  },
});
```

Server action (alternative) returning `Persona[]` without persistence:
```ts
import { generatePersonas } from '@/lib/personas/generate';

const personas = await generatePersonas({
  group: 'tech',
  count: 3,
  context: { location: 'San Francisco, CA' },
});
```

Audience → overview + subsegments example:
```ts
import { api } from '@/convex/_generated/api';
import { fetchAction } from 'convex/nextjs';

const bundle = await fetchAction(api.audienceGroups.suggestBundle, {
  text: 'Young professionals seeking eco‑friendly commuting options',
  count: 6,
});
// bundle: { description: string, groups: Array<{ id, label, description, color, percent }> }
// Pass bundle.description as audienceDescription and a chosen bundle.groups[i] as context.segment when generating personas.
```

Batch persona generation across multiple groups example:
```ts
import { api } from '@/convex/_generated/api';
import { fetchAction } from 'convex/nextjs';

const personas = await fetchAction(api.personas.generateForGroups, {
  groups: [
    { id: 'urban-cyclists', label: 'Urban Cyclists', description: 'Daily commuters...', color: '#22AA88' },
    { id: 'weekend-riders', label: 'Weekend Riders', description: 'Recreational cyclists...', color: '#5566FF' },
  ],
  total: 16,
  audienceId: 'aud-123',
  context: {
    location: 'Austin, TX',
    audienceDescription: 'Young professionals seeking eco‑friendly commuting options',
  },
});
// Returns 16 personas distributed evenly across the 2 groups, all tagged with audienceId 'aud-123'
```

Ad variants example:
```ts
const variants = await fetchAction(api.ads.generateVariants, {
  count: 3,
  source: { headline: 'Boost recovery', description: 'Plant‑based protein 20g, clean formula.' },
});
```

Simulation example:
```ts
const reactions = await fetchAction(api.simulation.simulate, { persona, ads });
```

### Error handling and safety
- `generateObject` may throw `NoObjectGeneratedError`. We log provider details (cause, text, response, usage) and rethrow.
- Cap `count` (e.g., 1–10 for personas, 1–32 for batch generation) to control cost/latency.
- Avoid logging sensitive content; keep `chain_of_thought` and reasoning fields concise (≤500 chars in schemas).
- Temperature: persona generation uses `0.2` for reduced variance and better schema adherence; other agents use model defaults.

### Environment & configuration
- Set `GOOGLE_GENERATIVE_AI_API_KEY` in Convex: `npx convex env set GOOGLE_GENERATIVE_AI_API_KEY <key>`.
- Ensure `ai`, `@ai-sdk/google`, and `zod` are installed.

### Convex development guide (best practices)
- TypeScript: concise, functional style; descriptive variable names; prefer `interface` over type aliases for objects.
- Components: export named components; decompose into subcomponents/helpers; keep client components minimal.
- Errors: fail early; log actionable details; surface user‑friendly messages; validate inputs with Zod on boundaries.
- UI: shadcn/ui, Radix primitives, Tailwind; responsive, mobile‑first.
- Performance: minimize `use client`, state, and effects; prefer RSC; use `Suspense`; dynamic import heavy UI; optimize images.
- URLs/State: prefer `nuqs` (URL state) when applicable; watch Core Web Vitals; keep `useClient` limited.
- Convex data: prefer indexed queries over `.filter()` chains. Define indexes in `schema.ts` and query with `.withIndex(...)`.
- Actions vs mutations vs queries:
  - Use **actions** for external network I/O (e.g., calling AI providers), then commit via **mutations**.
  - Use **queries** for reads; paginate or cap results.
- HTTP Router & scheduled jobs: keep handlers small, validate inputs, and reuse domain helpers.
- File handling: upload via generated URL, then persist storage IDs in mutations.

Index example (messages table):
```ts
// schema.ts
defineTable({
  channel: v.id('channels'),
  body: v.string(),
  user: v.id('users'),
})
  .index('by_channel', ['channel'])
  .index('by_channel_user', ['channel', 'user']);

// query
await ctx.db
  .query('messages')
  .withIndex('by_channel', q => q.eq('channel', channel))
  .collect();
```

### Extensibility roadmap
- ✅ Ad variants generator using `generateObject` with dedicated Zod schemas (implemented in `convex/ads.ts`).
- ✅ Simulation (reaction) generator using `generateObject` with dedicated Zod schemas (implemented in `convex/simulation.ts`).
- ✅ Convex queries to fetch personas by `audienceGroup` and `persona_id` using indexes (implemented: `listByGroup`, `getByPersonaId`, `listByAudienceId`).
- Optional: a streaming variant (`streamObject`) for interactive UIs to show personas/ads/reactions as they're generated.
- Add rate limiting/quotas per user for generation endpoints.
- Add persistence for ad variants and simulation results (currently generated on-demand only).
- Add table for audience sessions with metadata (description, created_at, etc.).
- Add pagination for persona queries (currently capped at 100 per query).

### Quick checklist
- [ ] Inputs validated with Zod
- [ ] Results persisted via Convex mutation
- [ ] Indexes defined for query patterns
- [ ] Sensitive fields not logged; concise reasoning
- [ ] Client components minimized; RSC where possible

### UI notes
- In `app/product/simulation/audience-builder/page.tsx`, audience text is converted into an overview and subsegments via `suggestBundle`.
- For each subsegment, the page calls `generate` to create one persona per group, progressively rendering them as they complete.
- Personas are displayed using `PersonaBrowser` component, which shows detailed persona information including profile, personality traits, and pre-ad context.
- The generation chain of thought is visualized using `GenerationChainOfThought` component, showing the progress of audience segmentation and persona generation for each group.
- All personas from a session are tagged with a shared `audienceId` for filtering and retrieval.


